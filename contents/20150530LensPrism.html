<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
    var SlideList = []
    var SlideIndex = 0;
    var Title = "Slide";

    function init(){
      SlideList = document.getElementsByName("pages");
      changeSlide(0);
    }

    function changeSlide(index){
      if(0 > index || index >= SlideList.length) return;
      for(i = 0; i < SlideList.length ;i++) {
        if(i == index) {
          SlideList[i].style.display = "table-cell";
          document.title = Title + " - " + (i + 1) + "/" + SlideList.length;
        } else {
          SlideList[i].style.display = "none";
        }
      }
      SlideIndex = index;
    }

    document.onkeydown = function(e){
      if(e.keyCode == 39) changeSlide(SlideIndex + 1);
      if(e.keyCode == 37) changeSlide(SlideIndex - 1);
    }
  </script>
  <style>
    html, body {
      height: 98%;
      width: 99%; 
      overflow:hidden;
    }
    h1, h2, h3, ul, p {
      margin:0px; 
      padding:0px;
    }
    .slide {
      font-size:45pt;
      display:inline-table; 
      width:100%; 
      height:100%; 
    }
  </style>
<head>
<body onload="init()" style="height:100%">
  <div class="slide">

<div name="pages" style="font-size:50px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><h1>LensでHaskellを<br />もっと格好良く！</h1><p>2015/5/30 Lens&Prism勉強会<br />by ちゅーん(@its_out_of_tune)</p></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>自己紹介</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:66%;float:left"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>野生のHaskller(27♂)</li><li>東京都近郊に生息</li><li>休職中<br /><br /></li><li>クルージング(スケボー)</li><li>SOUND VOLTEX(音ゲー)</li><li>リトルノア（スマフォゲー）<br /><br /></li><li>ヲ級ちゃん可愛い</li><li>艦これやってない</li></ul></div></div></div><div class="block" style="height:100%;width:33%;float:left"><div class="block" style="height:50%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/my_icon2.gif" style="width:90%"/></div></div></div><div class="block" style="height:50%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;font-size:40px;color:#000000;background:#c8c8c8;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>HN:　ちゅーん<br /><br />Twitter:<br />　@its_out_of_tune<br />Github:<br />　tokiwoousaka<br /></p></div></div></div></div><div style="clear:both"></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>自己紹介</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>Takahashi Monad：<br />　スライド作成用の言語内DSL<br />　拡張済み／複雑なスライドも作れる<br />　本スライドもこれで作成<br /><br />　GHC7.10非対応 。゜。゜（ノД｀）゜。゜。</li><li>Sarasvati：<br />　開発中のオーディオインターフェイス<br />　PortAudioのラッパーのラッパー</li></ul></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>HaskellのLens</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>HaskellのLens</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>2013/3/31 ekmett勉強会で、<br />Haskellのlensについて発表。<br /><br /></p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>基本的な使い方</li><li>基本的な仕組みと実装</li><li>簡単な応用等</li></ul></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>HaskellのLens</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>旧スライドでの発表</h1></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>HaskellのLens</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>ScalaのLensと実装が違う？<br /> 　　-> van Laarhoven lens<br /><br /></li><li>考案者 van Laarhovenがブログ記事に</li><li>Russell O'Connor証明等を論文に<br /><br /></li><li>ekmett/lensはvan Laarhoven lensの拡張</li><li>Haskellのlensはもっとすごいぞっ！</li></ul></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><h1>Opticから見たLens/Prism</h1><p>2015/5/30 Lens&Prism勉強会<br />by ちゅーん(@its_out_of_tune)</p></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Lensの限界</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Lensアクセッサを利用すれば、<br />複雑な構造へアクセスする事が出来る</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>(1, (2, 3, (4, 999)), 6)^._2._3._2 -- 999<br /><br />(1, (2, 3, (4, 5)), 6)&_2._3._2.~999 -- (1, (2, 3, (4, 999)), 6)</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>fooような構造から"999"を操作したい場合は？<br />barのような場合は？</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>let foo = (1, Left (999, 3), 4) <br />    :: (Int, Either (Int, Int) String, Int)<br /><br />let bar = (1, Right "Test", 4) <br />    :: (Int, Either (Int, Int) String, Int)</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>頑張ってlensだけでGetする<br /></p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>print $ case foo^._2 of <br />  Left inner -> Just (inner^._1)<br />  Right _ -> Nothing<br /><br />print $ case bar^._2 of <br />  Left inner -> Just (inner^._1)<br />  Right _ -> Nothing</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>(´ﾟдﾟ｀)ｴｰ</h1></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>頑張ってlensだけでSetする</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>(_2%~(\case <br />  Left x -> Left $ x&_1.~111<br />  Right x -> Right x)) foo<br /><br />(_2%~(\case <br />  Left x -> Left $ x&_1.~111<br />  Right x -> Right x)) bar<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>｡･ﾟ･(ﾉ∀`)･ﾟ･｡</h1></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lensの限界</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;font-size:80px;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>lensは便利だけど<br />直和型が混ざると使えない<br /><br />　　　　　　-> Primsを使おう！</p></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Prismでパターンマッチ</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Lensは直和型(Maybe, Either等)には使えない。<br /><br />このような場合、<br />Prismという型を持つアクセッサを使う。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Prism s t a b = ... <br /><br />_Left :: Prism (Either a c) (Either b c) a b<br />_Right :: Prism (Either c a) (Either c b) a b<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismを使った値の取得には(^?)を使う。<br /><br />Maybe型を返し、値が取得できなかった場合、<br />結果はNothingとなる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p> let left5 = Left 5 :: Either Int String<br /> let rightHoge = Right "Hoge" :: Either Int String<br /><br /> left5^?_Left      -- Just 5<br /> left5^?_Right     -- Nothing<br /> rightHoge^?_Left  -- Nothing<br /> rightHoge^?_Right -- Just "Hoge"</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismはマッチした場合のみ変更可能な、<br />Setterとして機能する。</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>left5&_Left.~999      -- Left 999<br /><br />rightHoge&_Left.~999  -- Right "Hoge"</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>使い方はLensと同様</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>取得したい値がMonoidの場合に限り、(^.)が使える。<br />マッチ出来なかった場合の値はmemptyになる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>Just "hoge"^._Just                  -- OK "hoge"<br />Just 114514^._Just                  -- NG<br />Just (Sum 184)^._Just               -- OK Sum { getSum = 184 }<br />(Nothing :: Maybe (Sum Int))^._Just -- OK Sum { getSum = 0 }<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismはre関数を使う事によって、<br />データコンストラクタを被せるGetterになる。<br />値をSetする事は出来ない。<br /><br />同様の事は、to関数を使っても実現可能。</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>print $ 100^.re _Just -- Just 100<br /><br />print $ 100^.to Just  -- Just 100</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismでパターンマッチ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>makePrisms関数を使えば、<br />独自の型に対してPrismアクセッサを作成できる。<br /></p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>data Foo a b = Hoge a | Piyo b | Fuga String <br />  deriving (Show, Read, Eq, Ord)<br /><br />makePrisms ''Foo<br /><br />------ 以下のPrismが生成される ------<br /><br />_Hoge :: Prism (Foo a c) (Foo b c) a b<br />_Piyo :: Prism (Foo c a) (Foo c b) a b<br />_Fuga :: Prism (Foo a b) (Foo a b) String String<br /><br /></p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Prismの合成</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの合成</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>PrismもLensと同様、関数合成によって合成可能。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>let justLeft = Just (Left 5) :: Maybe (Either Int String)<br />let justRight = Just (Right "Hello") :: Maybe (Either Int String)<br /><br />justLeft^?_Just._Left   -- Just 5<br />justLeft^?_Just._Right  -- Nothing<br />justRight^?_Just._Right -- Just "Hello"<br />justRight^._Just._Right -- "Hello"</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの合成</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>当然、PrismとLensを組み合わせても、<br />アクセッサとして利用可能。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>let foo = (1, Left (999, 3), 4) <br />    :: (Int, Either (Int, Int) String, Int)<br />let bar = (1, Right "Test", 4) <br />    :: (Int, Either (Int, Int) String, Int)<br /><br />print $ foo^?_2._Left._1     -- Just 999<br />print $ foo&_2._Left._1.~111 -- (1,Left (111,3),4) <br />print $ bar^?_2._Right       -- Just "Test"<br />print $ bar^._2._Rightn      -- "Test"</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの合成</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Lensと合成した後はre関数が使えない。<br />合成したのがPrism同士ならば問題ない。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>  re (_Just._1)                 -- NG<br /><br />  (100^.re (_Just._Left) <br />    :: Maybe (Either Int Int))  -- OK Just (Left 100)</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの合成</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismの合成 -> re関数<br />Prismにre関数 -> 合成<br /><br />では、結果の構造が逆になるため注意。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>print $ (100^.re _Just.re _Left<br />  :: Either (Maybe Int) Int)  -- Left (Just 100) <br /><br />print $ (100^.re (_Just._Left)<br />  :: Maybe (Either Int Int))  -- Just (Left 100)</p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>State上のPrism</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>State上のPrism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Lens同様、<br />MonadStateインスタンス上で状態へのSetが可能。<br /></p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>sample :: State (Int, Bool, Maybe (Int, String)) ()<br />sample = do<br />  _1 .= 100<br />  _3._Just._2 .= "Hello, Prism!"<br />  return ()</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>State上のPrism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>取り出したい値がモノイドならば<br />use関数を用いた値のGetが出来る。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>sample :: State (Int, Bool, Maybe (Int, String)) String<br />sample = do<br />  str <- use $ _3._Just._2<br />  return str</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>State上のPrism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>モノイドでない場合はpreuse関数を使う。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>sampleState2 :: State (Int, Bool, Maybe (Int, String)) (Maybe Int)<br />sampleState2 = do<br />  int <- preuse $ _3._Just._1<br />  return int</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>State上のPrism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>取得したい値がIntならば次のようにしても良い。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>sample :: State (Int, Bool, Maybe (Int, String)) (Sum Int)<br />sample = do<br />  int <- use $ _3._Just._1.to Sum<br />  return int</p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>色々なFunctor</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Functorのイメージ：<br />　実用上の認識に囚われない方が良い。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/ufunctor.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>持ち上げ先の矢印を逆にする</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/ucontravariant.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>FunctorとContravariant</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Functor f where<br />  fmap      :: (a -> b) -> f a -> f b<br /><br />class Contravariant f where<br />  contramap :: (a -> b) -> f b -> f a<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>シンキング・タイム(10秒)</h1></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Contravariantになるような<br />データ構造を考えてみよう！</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>例１：関数</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>newtype Op b a = Op { runOp :: a -> b }<br /><br />instance Contravariant (Op r) where<br />  contramap f (Op g) = Op $ g . f</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>例２：Const</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>newtype Const a b = Const { getConst :: a }<br /><br />instance Contravariant (Const r) where<br />  contramap _ = Const . getConst<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>２つの関数を一つに束ねる</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/ubifunctor.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Bifunctor</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Bifunctor f where<br />  bimap :: (a -> b) -> (c -> d) -> f a c -> f b d<br /><br />  first :: (a -> b) -> f a c -> f b c<br />  first f = bimap f id<br /><br />  second :: (b -> c) -> f a b -> f a c<br />  second f = bimap id f</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Bifunctorの例：タプル、Const 等</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>instance Bifunctor (,)  where<br />  bimap f g (x, y) = (f x, g y)<br /><br />instance Bifunctor Const  where<br />  bimap f _ (Const x) = Const $ f x</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Bifunctorの矢印を片方だけ反転</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/uprofunctor.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Profunctor</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Profunctor p where<br />  dimap :: (c -> a) -> (b -> d) -> p a b -> p c d<br /><br />  lmap :: (a -> b) -> p b c -> p a c<br />  lmap f = dimap f id<br /><br />  rmap :: (b -> c) -> p a b -> p a c<br />  rmap = dimap id<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>色々なFunctor</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>矢印で表せるような、合成可能な構造は、<br />Profunctorになり得る。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/uprofunctor2.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Lens, Optic, Prism</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Lensの定義を再掲</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Lens s t a b<br />  = forall f. Functor f => (a -> f b) -> s f t</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Functorの制約を外す</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type LensLike f s t a b = (a -> f b) -> s -> f t</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>これ以上の多相化は出来ない？</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>シンキング・タイム(10秒)</h1></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type LensLike f s t a b = (a -> f b) -> s -> f t</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>まだ抽象化出来る？</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Haskellでは関数も型コンストラクタ</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type LensLike f s t a b = (->) a (f b) -> (->) s (f t)<br />type Optic p f s t a b  = p    a (f b) -> p    s (f t)</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>合成出来るように中央の(->)は残しておく</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismの定義</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Prism s t a b = forall p f. <br />  (Choice p, Applicative f) => p a (f b) -> p s (f t)</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Choice型クラス？<br />後でまた詳しく説明します。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Profunctor p => Choice p where<br />  left' :: p a b -> p (Either a c) (Either b c)<br />  left' = dimap (either Right Left) (either Right Left) . right'<br /><br />  right' :: p a b -> p (Either c a) (Either c b)<br />  right' = dimap (either Right Left) (either Right Left) . left'<br /><br />instance Choice (->) where<br />  left' f (Left x) = Left $ f x<br />  left' _ (Right x) = Right x<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>LensもPrismもOpticで表現出来る。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Lens s t a b<br />  = forall f. Functor f                   => Optic (->) f s t a b<br /><br />type Prism s t a b <br />  = forall p f. (Choice p, Applicative f) => Optic p    f s t a b<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Lens, Optic, Prism</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>実際のlensライブラリでは、<br />Opticをさらに多相にしたOpticalも定義されている</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Optical p q f s t a b = p a (f b) -> q s (f t)<br />type Optic p f s t a b = Optical p p f s t a b</p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Opticで全体を見渡す</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>ekmett/lensのアクセサはすべて、<br />Optic型に属し、(.)で合成出来る</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Optic p f s t a b = p a (f b) -> p s (f t)</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>pとfに様々な制約を与える事で<br />様々なアクセッサを、体系的に扱う。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>Opticベースのlensなら・・・<br /><br /></li><li>合成について明示的に定義しなくて良い</li><li>lensモジュールに依存せずにアクセサを提供できる</li><li>Haskellの文法に適した記法が得られる</li><li>定式化／分析がしやすそう</li><li>恋人が出来る</li><li>お金持ちになれる</li><li>etc.. etc..</li></ul></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>ekmett/lensに定義されている、<br />Lensの仲間をざっと見ていこう。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/ulensfrends.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Equalityは、<br />pとfに任意の型を取れるようにしたもの。<br />a=b, s=tを表す。（つまり何も変換出来ない）</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Equality s t a b = forall p f. )ptic p f s t a b<br />type Equality' s a = Equality s s a )<br /><br />id :: Equality a b a b<br />   :: forall p f. p a (f b) -> p a (f b)<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>同型を表すIsoは、以下のように定義される。</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Iso s t a b <br />  = forall p f. (Profunctor p, Functor f) => Optic p f s t a b<br />type Iso' s a = Iso s s a a</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>s=a, t=bでGetterになるため<br />通常Iso'の方を使う事になる。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>iso関数を使えば簡単にIsoが作れるが、<br />変換が同型射である事は実装者が保証する。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>iso :: (s -> a) -> (b -> t) -> Iso s t a b<br />iso f g = dimap f (fmap g)<br /><br />boolMaybe :: Iso' Bool (Maybe ())<br />boolMaybe = iso bm mb<br />  where<br />   bm :: Bool -> Maybe ()<br />   mb :: Maybe () -> Bool</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>from関数はIsoの向きを逆にする。<br />尚、ExchangeはProfunctor、IsoはAnIsoになる。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>data Exchange a b s t = Exchange (s -> a) (b -> t)<br />instance Profunctor (Exchange a b) where<br />  dimap f g (Exchange h i) = Exchange (h . f) (g . i)<br /><br />type AnIso s t a b = Optic (Exchange a b) Identity s t a b<br /><br />from :: AnIso s t a b -> Iso b a t s<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>IsoをGetterとして使う例。<br />もちろん、問題なくSetterにもなる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>(True, 10)^._1.boolMaybe         -- Just ()<br />(False, 10)^._1.boolMaybe        -- Nothing<br />(Just (), 10)^._1.from boolMaybe -- True<br />(Nothing, 10)^._1.from boolMaybe -- False</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Isoのp::Profunctorを(->)に固定するとLens。<br />p::ProfunctorをChoiceにし、<br />f::FunctorをApplicativeにすればPrismになる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Lens s t a b<br />  = forall f. Functor f                   => Optic (->) f s t a b<br /><br />type Prism s t a b <br />  = forall p f. (Choice p, Applicative f) => Optic p    f s t a b<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismから、a=t, f=bとして、<br />pにBifunctor制約を追加、fの制約をSettableに</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Review t b = forall p f. <br />  (Choice p, Bifunctor p, Settable f) => Optic p f t t b b</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>尚、Settableは要Functor（後述）なので、<br />PrismはReviewになる。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>TaggedはChoiceでありBifunctor<br />かつIdentityはSettableなので、<br />ReviewはAReviewになる、PrismもAReview</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>newtype Tagged t a = ... <br />instance Bifunctor Tagged where<br />instance Choice Tagged where<br />instance Settable Identity where<br /><br />type AReview t b = Optic' Tagged Identity t b<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Reviewを扱う関数。<br />可能な限り多相化されてるのでわかりづらい。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>unto :: (Profunctor p, Bifunctor p, Functor f) <br />    => (b -> t) -> Optic p f s t a b<br />un :: (Profunctor p, Bifunctor p, Functor f) <br />    => Getting a s a -> Optic p f a a s s<br />re :: Contravariant f => AReview t b -> LensLike f b b t t</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>だいたいこんな感じ</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>unto :: (b -> t) -> Review s t a b<br />un :: Getter s a -> Review a a s s<br />re :: Review t t b b -> Getter b t</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>re関数でGetterに出来る。<br />てか、Getterにしないと何もできない。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>やたら多相化されてるGetting/Getter</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Getting r s a = Optic (->) (Const r) s s a a <br />type Getter s a = forall f. <br />    (Functor f, Contravariant f) => Optic (->) f s s a a</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Const r は Contravariant（後述）なので、<br />GettingはGetterになる。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>SetterはIdentityが多相化されていて、<br />Settable型クラスになっている。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Setter s t a b <br />  = forall f. Settable f => Optic (->) f s t a b</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>a=t, f=b に固定、fがContravariantかつApplicative</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Fold s a = forall f. <br />    (Contravariant f, Applicative f) => Optic (->) f s s a a</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Getter, Traversalの制約を強くしたもの、<br />当然、LensもPrismもFoldになる。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Opticで全体を見渡す</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>以下の２つの演算子はFoldのためのもの。<br />（(^..)の説明は割愛。）<br /></p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>(^..) :: s -> Getting (Endo [a]) s a -> [a]<br />(^?) :: s -> Getting (First a) s a -> Maybe a</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Getting r s a の r に指定する型がモノイドなら<br />その型はFoldになる（後述）</p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>Prismの原理</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>lensライブラリは巨大＆複雑</li><li>すべての機能を把握するのは超大変</li><li>よく使うところから少しづつ掘り下げていこう</li><li>今回はPrism周りの仕組みを解説</li></ul></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>まずは、ChoiceとPrismを再掲</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Profunctor p => Choice p where<br />  left' :: p a b -> p (Either a c) (Either b c)<br />  left' = dimap (either Right Left) (either Right Left) . right'<br /><br />  right' :: p a b -> p (Either c a) (Either c b)<br />  right' = dimap (either Right Left) (either Right Left) . left'<br /><br />type Prism s t a b = forall p f. <br />    (Choice p, Applicative f) => Optic p f s t a b</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Choiceの二大インスタンス<br />その１：関数</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>instance Choice (->) where<br />  left' f (Left x) = Left $ f x<br />  left' _ (Right x) = Right x</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Choiceの二大インスタンス<br />その２：Tagged</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>newtype Tagged t a = Tagged { unTagged :: a } <br /><br />instance Bifunctor Tagged where<br />  bimap _ f = Tagged . f . unTagged<br />instance Profunctor Tagged where<br />  dimap _ f = Tagged . f . unTagged<br />instance Choice Tagged where<br />  right' = Tagged . Right . unTagged</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>ChoiceはProfunctorに別の変換を与える。<br />ちなみに、足し算はEitherを表す（圏論の慣習）</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/uchoice.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismを作るためのprism関数<br />dimapとright'で順同型射からPrismを作れる</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b<br />prism bt seta = dimap seta (either pure $ fmap bt) . right'<br /><br />_Just :: Prism (Maybe a) (Maybe b) a b<br />_Just = prism Just $ \case<br />  Just x -> Right x<br />  Nothing -> Left $ Nothing<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Setterの場合、over関数のタイミングで、<br />Optic p f s t a b の f が Identityに固定される</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>over :: Setter s t a b -> (a -> b) -> s -> t<br />over l f = getIdentity . l (Identity . f)<br /><br />set :: Setter s t a b -> b -> s -> t<br />set a = over a . const<br /><br />(.~) = set<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>改めて、Setterの型と比較。</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Setter s t a b <br />  = forall f. Settable f => Optic (->) f s t a b<br />type Prism s t a b = forall p f. <br />    (Choice p, Applicative f) => Optic p f s t a b</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>関数はChoiceのインスタンスなので問題なし<br />Settableってなんだ。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>実はよくわかってない(´・ω・｀)<br /><br />けどIdentityはSettableのインスタンスなので、<br />pureとuntaintedがあればover相当の関数は作れるはず。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>class Functor g => Distributive g where<br />  distribute :: Functor f => f (g a) -> g (f a)<br />class (Applicative f<br />  , Distributive f, Traversable f) => Settable f where<br />  untainted :: f a -> a<br /><br />instance Settable Identity where<br />  untainted = getIdentity</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismアクセッサの動作を簡単にチェックしたい。<br />次のような型を作ってみよう。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>data Hoge = Foo String | Bar Int | Buz String deriving Show<br /><br />_Foo :: Prism Hoge Hoge String String<br />_Foo = prism Foo $ \case<br />  Foo s -> Right s<br />  x -> Left x<br /><br />_Bar :: Prism Hoge Hoge Int Int<br />_Buz :: Prism Hoge Hoge String String<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>f を Identityに固定する事で、<br />パターンにマッチした場合のみmap出来る事を、<br />次のようにして確認できる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>ghci> getIdentity . _Foo (Identity . (++"Piyo")) $ Foo "Hoge"<br />Foo "HogePiyo"<br />ghci> getIdentity . _Foo (Identity . (++"Piyo")) $ Bar 114514<br />Bar 114514<br />ghci> getIdentity . _Foo (Identity . (++"Piyo")) $ Buz "Hoge"<br />Buz "Hoge"<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>以下のように図に描くとわかりやすい。<br />profunctor や f の型を固定して考えてみよう。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/uprism.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Getterとして使う場合<br />Const r は Applicativeでない事に注意</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Prism s t a b = <br />    forall p f. (Choice p, Applicative f) => Optic p f s t a b<br /><br />type Getting r s a = Optic' (->) (Const r) s a <br /><br />foldOf :: Getting a s a -> s -> a<br />foldOf l = getConst . l Const<br /><br />(^.) = flip foldOf<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>ただし、Gettingのrがモノイドの場合に限り、<br />Const rがApplicativeになる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Getting r s a = Optic' (->) (Const r) s a <br /><br />instance Monoid m => Applicative (Const m) where<br />  pure x = Const mempty<br />  (<*>) _ = Const . getConst</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>prism関数の定義を再掲</p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b<br />prism bt seta = dimap seta (either pure $ fmap bt) . right'<br /><br /></p></div></div></div><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>マッチング出来ない場合は、<br />pureの部分でmemptyが取得される。</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Foldとして使う場合<br />ConstはContravariantになるので、<br />あとはFirst aがモノイドであればFoldになりそう。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Fold s a = forall f. <br />    (Contravariant f, Applicative f) => Optic' (->) f s a<br />type Getting r s a = Optic' (->) (Const r) s a <br /><br />(^?) :: s -> Getting (First a) s a -> Maybe a<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>FirstはMaybeと同型、<br />MaybeはMonoidになる。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>newtype First a = First { getFirst :: Maybe a }<br /><br />instance Monoid (First a) where<br />  mempty = First Nothing<br />  r@(First (Just )) `mappend` _  = r<br />  First Nothing `mappend` r = r<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>後はだいたいGetterの理屈と一緒<br />AccessingはGettingの変形</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>type Accessing p m s a = Optical p (->) (Const m) s s a a<br /><br />foldMapOf :: Profunctor p => Accessing p r s a -> p a r -> s -> r<br />foldMapOf l f = getConst . l (Const #. f)<br /><br />(^?) :: s -> Getting (First a) s a -> Maybe a<br />s ^? l = getFirst $ foldMapOf l (First #. Just) s<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>re関数の実装、ようやくTagged登場<br />TaggedはChoice、IdentityはApplicativeの、<br />それぞれインスタンスなのでPrismはAReview</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>re :: Contravariant f => AReview t b -> LensLike f b b t t<br />re p = to (getIdentity #. unTagged #. p .# Tagged .# Identity)<br /><br />newtype Tagged t a = Tagged { unTagged :: a }<br />type AReview t b = Optic' Tagged Identity t b<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>prismの図を再掲、<br />re関数の動作原理を考えてみよう。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><img src="../img/LensPrism/uprism.png" style="width:90%"/></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>直接コンストラクタを被せるのは、<br />簡単に試す事ができる。<br /><br />純粋な関数になれば、to関数でGetterに出来る。</p></div></div></div><div class="block" style="height:50%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>ghci> :t _Just $ Tagged (Identity 10)<br />_Just $ Tagged (Identity 10)<br />  :: Num b => Tagged (Maybe a) (Identity (Maybe b))<br />ghci> getIdentity . unTagged . _Just $ Tagged (Identity 10)<br />Just 10<br />ghci> getIdentity . unTagged . _Foo $ Tagged (Identity "Hoge")<br />Foo "Hoge"<br /></p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>reの実装は関数合成でも同じはず<br />(´・ω・｀)あれ？</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>--これでも良いはず<br />re :: Contravariant f => AReview t b -> LensLike f b b t t<br />re p = to (getIdentity . unTagged . p . Tagged . Identity)<br /><br />--実際<br />re :: Contravariant f => AReview t b -> LensLike f b b t t<br />re p = to (getIdentity #. unTagged #. p .# Tagged .# Identity)<br />--                     ^           ^     ^         ^<br />--                     why profunctor??</p></div></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>Prismの原理</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:33%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><p>Prismはただ単に順同型を表すので、<br />パターンマッチの用途に囚われず使える。</p></div></div></div><div class="block" style="height:66%;width:100%"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;vertical-align:middle;display:table-cell;font-size:30px;color:#000000;padding-left:8%;border-width:10;border-style:double;border-color:#000000;box-sizing:border-box;font-family:sens-selif,monospace;white-space:pre"><p>nat :: Prism' Integer Natural<br />nat = prism toInteger <br />  $ \i -> if i < 0 then Left i else Right (fromInteger i)<br /><br />5^?nat                   -- Just 5  :: Maybe Natural<br />(-5)^?nat                -- Nothing :: Maybe Natural<br />(10 :: Natural)^.re nat  -- 10      :: Integer</p></div></div></div></div></div><div name="pages" style="font-size:60px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;background:#c8c8c8;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>まとめ</h1></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>まとめ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table-cell;color:#000000;padding-top:3%;padding-left:8%;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><ul><li>Lensは便利</li><li>でも直和型には弱い</li><li>そんな時にはPrism！</li><li>LensもPrismもOpticで表せるよ</li><li>Opticでekmett/lens全体を見渡せる</li><li>Prismの原理を覗いてみたよ</li><li>Lens/Prismちょーすげぇ！</li></ul></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>まとめ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>てなわけで</h1></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:18%;width:100%;display:table;color:#ffffff;background:#646464;border-width:10;border-style:solid;border-color:#969696;box-sizing:border-box"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell"><h2>まとめ</h2></div></div></div><div class="block" style="height:81%;width:100%;display:table"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>みんな<br />Lensを使おう！</h1></div></div></div></div><div name="pages" style="font-size:50px"><div class="block" style="height:100%;width:100%;display:table"><div class="block" style="height:100%;width:100%;text-align:center;vertical-align:middle;display:table-cell;color:#000000;border-width:10;border-style:solid;border-color:#ffffff;box-sizing:border-box"><h1>ありがとうございました<br />m(_ _)m</h1></div></div></div>

  </div>
</body>
</html>
